[gd_scene load_steps=5 format=3 uid="uid://bloeiue5sua18"]

[sub_resource type="GDScript" id="GDScript_plxnk"]
script/source = "extends Node3D
@onready var mesh = $MeshInstance3D
@onready var area = $Area3D

## Interact entry point for each local item. This will be sent to the server
## in another function.
## 
## This function is present on every client (and host) mirror of an item and
## is merely a wrapper around [method server_update_state]. Use this function
## to identify if an item is interactable and then call the interaction through
## this method. See [method player.interact] for an example.
func interact():
	Logger.debug(\"item.interact: peer_id %d interacted with item\" \\
				% multiplayer.get_unique_id())
	
	# id of 1 is always the server. The server will verify this call
	# and then send it to all clients.
	server_update_state.rpc_id(1)

## Call the server to update the state of the item. The server will verify
## this request and then send it to all clients.
@rpc(\"any_peer\", 	# Any client can request and update in state
	 \"call_local\",	# Make sure client updates their local state too
	 \"reliable\"		# Make sure the server gets the request
) func server_update_state():
	var sender_id = multiplayer.get_remote_sender_id()
	Logger.debug(\"item.server_update_state: peer_id %d interacted with item\" \\
				% sender_id)
	
	# Find each node in the area of `area`, and if the player is the same one
	# who called this function, then propogate the call.
	# Note: get_overlapping_bodies conforms to the mask of `area`. Area at time of 
	# this comment has collision mask of 0b10 (position 2, Player).
	for node in area.get_overlapping_bodies():
		Logger.info(\"item.server_update_state: %s in range\" % node)
		# So long as the node is a player, it's name should be the peer_id
		# of that player. See [Main]
		if node.name == str(sender_id):
			Logger.info(\"item.server_update_state: %d is verified as in range\" \\
					   % sender_id)
			local_update_state.rpc()
		else:
			Logger.info(\"item.server_update_state: %s id != %d id\" \\
					  % [node.name, sender_id])
	
@rpc(\"authority\",	# Only accept rpc calls from the server
	 \"call_local\",	# Also initiate this call locally (on the server in this case)
	 \"reliable\"		# Make sure all clients get this call
) func local_update_state():
	Logger.info(\"local_update_state\")
	Logger.info(\"%d\" % multiplayer.get_unique_id())
	
	# Simple proof of function working
	mesh.hide()
"

[sub_resource type="BoxShape3D" id="BoxShape3D_k6ygt"]
size = Vector3(2, 2, 2)

[sub_resource type="BoxMesh" id="BoxMesh_3irdy"]
size = Vector3(2, 2, 2)

[sub_resource type="SphereShape3D" id="SphereShape3D_b3u3q"]
radius = 10.0

[node name="Item" type="Node3D"]

[node name="RigidBody3D" type="RigidBody3D" parent="."]
collision_layer = 4
collision_mask = 7
mass = 1000.0
script = SubResource("GDScript_plxnk")

[node name="CollisionShape3D" type="CollisionShape3D" parent="RigidBody3D"]
shape = SubResource("BoxShape3D_k6ygt")

[node name="MeshInstance3D" type="MeshInstance3D" parent="RigidBody3D"]
mesh = SubResource("BoxMesh_3irdy")
skeleton = NodePath("../..")

[node name="Area3D" type="Area3D" parent="RigidBody3D"]
collision_mask = 2

[node name="CollisionShape3D" type="CollisionShape3D" parent="RigidBody3D/Area3D"]
shape = SubResource("SphereShape3D_b3u3q")
